{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE TupleSections #-}

module Mintz.Hspec.IO where

import Data.Proxy
import Control.Monad
import Control.Monad.Writer
import Test.Hspec

-- | This type holds IO actions launched before and after external IO action.
data PrecedingIO a r = forall s.
    PrecedingIO { precede :: IO s -- ^ This action is launched before external action and saves a value.
                , genArg :: s -> IO a -- ^ Generates a value for the first argument of @execAfter@ by saved value.
                , execAfter :: a -> r -> IO () -- ^ IO action launched after extrenal action.
                                               --   @a@ is generated by @genArg@. @r@ is the result of external action.
                }

-- | Existential type of @PrecedingIO a r@ used to store their objects into a list.
data PrecedingIO' r = forall a. PrecedingIO' { precedingIO :: PrecedingIO a r }

-- | Writer monad accumulating @PrecedingIO@s.
type Precedable r a = Writer [PrecedingIO' r] a

-- | Add a @PrecedingIO@ holding given actions.
precedeIO :: IO s -- ^ Preceding IO action.
          -> (s -> IO a) -- ^ Converts the result of preceding action to the argument of posterior action.
          -> (a -> r -> IO ()) -- ^ Posterior action.
          -> Precedable r () -- ^ Returns no value.
precedeIO p g e = tell $ [PrecedingIO' (PrecedingIO p g e)]

precedeIO' :: (r -> IO ())
           -> Precedable r ()
precedeIO' e = precedeIO (return ()) return (\_ r -> e r)

-- | Executes @PrecedingIO@s on the execution of an IO action.
runPrecedable :: IO r -- ^ IO action.
              -> Precedable r a -- ^ IO actions executed before and after the first argument.
              -> IO a -- ^ Value returned by the action.
runPrecedable f p = do
    let (v, pio) = runWriter p
    seq <- precedeIOs pio
    r <- f
    sequence_ $ map (\s -> s r) seq
    return v

precedeIOs :: [PrecedingIO' r]
           -> IO [r -> IO ()]
precedeIOs [] = return []
precedeIOs (PrecedingIO' (PrecedingIO {..}) : cs) = do
    s <- precede
    let e = \r -> genArg s >>= (flip execAfter) r
    base <- precedeIOs cs
    return $ e : base